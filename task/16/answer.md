## 課題 1

### インデックスの仕組み

インデックスとは、その名の通り「索引」のことになります。

例えば辞書で「プログラミング」という言葉を検索する際に、
１ページ目から順番にページをめくっていって目的の単語「プログラミング」を探そうとすると途方もない時間がかかってしまうと思います。

そこで、通常は以下のような手段を取るはずです。

1. 「索引」を使って辞書の何ページに「プログラミング」があるのかを確かめる。
2. 上記の該当ページに遷移する
3. 該当ページ上で改めて目的の単語「プログラミング」を探す

この手順と同じようなことを行うのがデータベースにおける「インデックス」という仕組みになります。

### slow query log を調べる意味

そもそも闇雲に INDEX を貼ることはアンチパターンです。

これは俗に「インデックスショットガン」と呼ばれます。

このアンチパターンの問題として、例えば INDEX を貼ると「INSERT/UPDATE/DELETE が遅くなる」という問題があります。

つまりインデックスを貼ればその分 DB 全体のパフォーマンスが落ちることに繋がってしまうのです。

これを避けるために、(コード上どのクエリがボトルネックになっているか不明な状況での)パフォーマンス改善のためには slow query log を調べることが通常です。

slow query log には実際に問題のある(遅い)クエリが残っているので、それらクエリに対して EXPLAIN をかけ実行計画を確認して、適切にインデックスがかかっているかどうかを確認することになります。

その上で必要十分かつ最低限のインデックスをかけることが重要です。

### カーディナリティとは

「列に格納されるデータの値にどのくらいの種類があるのか？」をカーディナリティといいます。

例えばユーザー ID はユニークであり、かつサービスの規模が大きくなるにつれユーザー ID も増えていきますのでカーディナリティが高いと言えます。

逆に性別のような値は「男/女/(その他など)」くらいしかありませんのでカーディナリティは低いと言えます。

カーディナリティが低い列に対する INDEX は有効活用できないため避けるべきです。

極端な例ですが、例えば男女比が 99:1 であり、そこに where 条件で「男」を指定して検索をかける場合、INDEX を使用してもテーブル全体の 99 %に対して検索をかけることになってしまうのでフルスキャンとほぼ変わらない効率になってしまいます。

### カバリングインデックスとは

INDEX に含まれているデータのみが必要な場合は、つまり INDEX を読み込むだけで良くなるため、実際のテーブルを読み込まずに結果を返せることになります。

これがカバリングインデックスと呼ばれるものです。
(INDEX が実行するクエリ全体をカバーしている、という意味合い)
